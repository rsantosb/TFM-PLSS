%!TEX root = ../TFMRocioSantos.tex

\chapter{Analisis de Resultados}
\label{cap:analisis}

%\chapterquote{Frase célebre dicha por alguien inteligente}{Autor}

En este capítulo se realiza un análisis comparativo de los resultados obtenidos con los del uso estándar de la reescritura y se analiza el rendimiento de la aplicación.


% *****************************************************
\section{Comparación con otros Sistemas de Búsqueda}

Ejecución estrategias/rew y el paper de IEEE Access.
\smallskip

Habría que tomar varios casos de softdish y para cada uno:

(1) ejecutarlos en cada sistema con todas las estrategias

(2) comprobar que los resultados son distintos para cada función de estrategia.
Explicar el significado de cada función (se da más peso a los valores desconocido, o menos, etc.) 

(3) construir la matriz del soft set asociado

(4) calcular matemáticamente y analizar el cv según cada método




% *****************************************************
\section{Análisis del Rendimiento}
Por último, se comentan algunos aspectos sobre el rendimiento del programa.
Se muestra también una comparativa entre resultados de reescritura guiados para los distintos choice values implementados y con el sistema de reescritura nativo de Maude.
\medskip

Tiempo ejecución:
para cada función PLSS
y con rew
\smallskip

Analizar que pasa si...

Si crece el número de atributos

Si crece el número de valores desconocidos

Si crece el número de términos alcanzables
\smallskip

unbound?



% *****************************************************
\section{TFM ToDo Pendientes}

Me preocupa el total de la implementación. Para el TFM lo ideal sería tener migración + nuevos
comandos + nueva funcionalidad + nuevos ejemplos. Ahora entiendo que estamos en
migración + nuevos ejemplos, que deja el trabajo muy justo, porque aunque el meta-intérprete
y la I/O en Maude no sean tan "normales" como en otros lenguajes no dejamos de tener una
variante de la interfaz Full Maude, con las nuevas estrategias todavía programadas en Core
Maude y con el comando de búsqueda reciclado. El tribunal que tenemos en el DSIC ya suspendió 
a un estudiante en septiembre y no quiero que vayamos con lo justo, porque va a ser complicado
para todos. Por eso, si no me estoy equivocando, nos quedaría la capacidad de definir de nuevas
estrategias para calcular los * desde la gramática y no desde Core Maude, ¿verdad?
\medskip

\textbf{TODO Pendientes}:

Revisar y citar cosas no propias!!!

2. Que no parezca todo literal de traducción!!!

3. Añadir referencias de los artículos en que se basan (sobre todo en la comparativa)
\medskip



Buenas,

Fenomenal, comento entre líneas.

- Retoqué el título y el resumen.

El título es razonable oficial, hay que tener uno definitivo para notificarlo.
 
- Todavía no hay nada hecho de la introducción y conclusiones. En las conclusiones quiero poner el análisis con otros métodos y del rendimiento.

El rendimiento debería tener su propia sección, creo yo, porque si no se nos va a ir a una sección de conclusiones muy larga. 
 
- Apéndice A con varios ficheros de código.

El código es un rollo tenerlo en la memoria ocupando páginas, con el repositorio basta.
 
- Apéndice B con ejemplos de ejecución.

Casi te diría lo mismo, que el repositorio tenga todo preparado para ser ejecutado. No veo mal
conservar este apéndice, pero como guía de referencia rápida.

Sobre el código:
Está funcionando, pero me falta hacer una limpieza de lo que no se utiliza.

¿Tenemos una manera de meter nuevas estrategias de manera sencilla?

Un abrazo,
 Adrián 
\medskip



El estudiante elaborará una memoria descriptiva del trabajo realizado, con una \textbf{extensión mínima recomendada de 50 páginas} incluyendo al menos una introducción, objetivos y plan de trabajo, resultados con una discusión crítica y razonada de los mismos, conclusiones y bibliografía empleada en la elaboración de la memoria.

Además del cuerpo principal describiendo el trabajo realizado, la memoria contendrá los siguientes elementos, que no computarán para el cálculo de la extensión mínima del trabajo:

\begin{itemize}
\item un resumen en inglés de media página, incluyendo el título en inglés,
\item ese mismo resumen en castellano, incluyendo el título en castellano,
\item una lista de no más de 10 palabras clave en inglés, y esa misma lista en castellano,
\item un índice de contenidos, y una bibliografía.
\end{itemize}

Todo el material no original, ya sea texto o figuras, deberá ser convenientemente citado y referenciado. En el caso de material complementario se deben respetar las licencias y copyrights asociados al software y hardware que se emplee.
\medskip



Una vez que se han descrito los bloques y el código del proyecto, se incluye ahora un ejemplo de ejecución (con todos los comandos implementados y también con la carga de un fichero de instrucciones)
\medskip

1. Lanzamos el comando \texttt{run} que nos devuelve una configuración con un portal que el interprete puede comunicarse y podemos tratrarlo. Esta configuración comienza en un estado \texttt{init} que luego se irá modificando.
La base de datos se encuentra vacía al comienzo.

2. Una vez lanzado, comenzará a entrar en las reglas con las que haga matching. En nuestro caso puede encontrarse con dos (\texttt{init-module} o \texttt{init-view}), ya que poseen el \texttt{msg} de \texttt{createdInterpreter}, es decir, que el intérprete fue creado. Además, pasará al estado \texttt{load-std-db}.  

3. Cuando se inserta el primer módulo o vista, existen varias formas de continuar. Entre ellas se encuentra \texttt{insertaModulo} o \texttt{insertaVista} si se ha insertado un módulo y \texttt{insertaModulo} o \texttt{insertaVista} si se ha insertado una vista.

Continúa en el mismo estado hasta que termina con los módulos y vistas, entonces pasará al estado \texttt{load-grammar} que carga la gramática.

Cuando se complete, cambia de estado a \texttt{load-user-mi} y crea un nuevo interprete.

Si ha sido creado con éxito, pasa al estado \texttt{load-user-mods} que sube el módulo aplanado hasta que se acaba la lista y cambia el estado a \texttt{idle} mientras espera recibir una entrada del usuario a través del prompt \texttt{PLSS>}.

Si la recibe entonces pasa al estado \texttt{parseComm}. Este se encargará de parsear el texto introducido por el usuario utilizando la gramática elevada al metanivel.

Si el texto fue parseado con éxito, entonces vuelve al primer paso, en caso contario cambiaría de estado a \texttt{print\&idle} y escribiría un mensaje de que el comando que se intenta introducir no existe.

Del estado en que se encuentra volvería a \texttt{idle} (tal como se muestra en el diagrama de estados) hasta que el usuario volviera a escribir algo en el prompt del programa.

Existen varios comandos que mi programa es capaz de gestioanr, entre ellos están: \texttt{load}, \texttt{red}, \texttt{softrew}, \texttt{softdishselect}, \texttt{specsoftrew}, \texttt{exit} y \texttt{q}. Con los dos últimos se saldría del programa.
\medskip



