%!TEX root = ../TFMRocioSantos.tex

\chapter{Estado de la Cuestión}
\label{cap:estadoDeLaCuestion}

En este capítulo se introducen las cuatro áreas en las que se fundamenta el trabajo.
La sección~\ref{Maude} trata del lenguaje de programación Maude.
La sección~\ref{MI} se refiere al metaintérprete de Maude.
La sección~\ref{SS} trata sobre la teoría de soft sets.
Por último, la sección~\ref{SS} introduce a Pathway Logic, el entorno de trabajo que se ha utilizado en la modelización de los sistemas biológicos.
En cada una de las secciones se estudia y presenta el conocimiento actual sobre estas áreas acompañado por referencias de publicaciones científicas relevantes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maude}\label{Maude}

En esta sección se muestra la definición, una visión general de los objetivos, la filosofía de diseño, los fundamentos lógicos, las aplicaciones y la estructura general de Maude.
\smallskip

%Definición Maude Wikipedia:
Maude es un lenguaje de programación para especificaciones formales mediante el uso de términos algebraicos. Se trata de un lenguaje interpretado que permite la verificación de propiedades y transformaciones sobre modelos y que permite también ejecutar la especificación como si fuera un prototipo~\citep{maude30}.
\smallskip

% Del manual de Maude 3.0 
% 2.1 MAUDE:
%\paragraph{1.1 Sencillez, expresividad y rendimiento}

El diseño del lenguaje de Maude puede entenderse como un esfuerzo por maximizar simultáneamente tres dimensiones: sencillez, expresividad y rendimiento.

Una amplia gama de aplicaciones puede expresarse de forma natural: desde sistemas secuenciales deterministas hasta sistemas no deterministas altamente concurrentes; desde pequeñas aplicaciones hasta grandes sistemas; desde implementaciones concretas hasta especificaciones abstractas; pasando por frameworks lógicos en los que se pueden utilizar formalismos completos, otros lenguajes y otras lógicas.

Las implementaciones concretas deben producir un rendimiento del sistema competitivo con otros lenguajes de programación eficientes.
\smallskip

Los programas en Maude deben ser lo más simples posible y tener un significado claro.
%
Las declaraciones de programación básicas de Maude son muy simples y fáciles de entender. Estas son ecuaciones y reglas, y en ambos casos tienen una semántica de reescritura simple donde las instancias del patrón del lado izquierdo se reemplazan por las instancias correspondientes del lado derecho.
\smallskip

Un programa de Maude que contiene solo ecuaciones se denomina \textit{módulo funcional}, es decir, define una o más funciones mediante ecuaciones, utilizadas como reglas de simplificación.
\smallskip

Por ejemplo, si construimos listas de identificadores (que son secuencias de caracteres que comienzan con el carácter ``\texttt{'}'' y pertenecen a la clase \texttt{Qid} con un operador~``\texttt{.}'' definido con notación infija:

\begin{lstlisting}[language=Maude]
	op nil : -> List .
	op _._ : Qid List -> List .
\end{lstlisting}
\medskip

\noindent
Entonces, por medio de operadores y ecuaciones, podemos definir una función de longitud de una lista y un predicado de pertenencia de un elemento a una lista:

\begin{lstlisting}[language=Maude]
	vars I J : Qid .
	var L : List .

	op length : List -> Nat .
	eq length(nil) = 0 .
	eq length(I . L) = s length(L) .

	op _in_ : Qid List -> Bool .
	eq I in nil = false .
	eq I in J . L = (I == J) or (I in L) .
\end{lstlisting}
\medskip

\noindent
donde:
  \verb$s_$ denota la función sucesora en números naturales,
  \verb$_==_$ es el predicado de igualdad en identificadores y
  \verb$_or_$ es la disyunción habitual en valores booleanos.
\smallskip

Las ecuaciones se especifican en Maude con la palabra clave \texttt{eq} y terminan con un punto. Se utilizan de izquierda a derecha como reglas de simplificación de ecuaciones.
\smallskip

Por ejemplo, si queremos evaluar la expresión:

\begin{lstlisting}[language=Maude]
	length('a . 'b . 'c . nil)
\end{lstlisting}
\medskip

\noindent
podemos aplicar la segunda ecuación de \texttt{length} para simplificar la expresión tres veces, y luego aplicar la primera ecuación una vez para obtener el valor final \texttt{s s s 0} (es decir, $3$):

\begin{lstlisting}[language=Maude]
	length('a . 'b . 'c . nil)
	= s length('b . 'c . nil)
	= s s length('c . nil)
	= s s s length(nil)
	= s s s 0
\end{lstlisting}
\smallskip

Esta es la utilización estándar de \textit{reemplazo de iguales por iguales} de ecuaciones en álgebra elemental y tiene una semántica muy clara y simple en la lógica de ecuaciones. El reemplazo de iguales por iguales se realiza aquí solo de izquierda a derecha y luego se invoca a la simplificación ecuacional o reescritura de ecuaciones.

Por supuesto, las ecuaciones de nuestro programa deben tener buenas propiedades como \textit{reglas de simplificación} en el sentido de que su resultado final debe existir y ser único. Este es de hecho el caso de las dos definiciones funcionales anteriores.
\medskip

En Maude, las ecuaciones pueden ser condicionales; es decir, solo se aplican si se cumple una determinada condición.
Por ejemplo, podemos simplificar una fracción a su forma irreducible usando la ecuación condicional:

\begin{lstlisting}[language=Maude]
	vars I J : NzInt .
	ceq J / I = quot(J, gcd(J, I)) / quot(I, gcd(J, I))
	    if gcd(J, I) > s 0 .
\end{lstlisting}
\medskip

\noindent
donde \texttt{ceq} es la palabra clave de Maude que introduce ecuaciones condicionales, \texttt{NzInt} es la clase para identificar los números enteros distintos de cero, y donde asumimos que las operaciones de cociente de enteros (\texttt{quot}) y máximo común divisor (\texttt{mcd}) ya han sido definidas por sus ecuaciones correspondientes.
\smallskip

Un programa de Maude que contiene reglas y posiblemente ecuaciones se denomina \textit{módulo de sistema}.
%
Las reglas también se calculan reescribiendo de izquierda a derecha, es decir, como las reglas de reescritura, pero no son ecuaciones; en cambio, se entienden como reglas de transición local en un sistema posiblemente concurrente.

Por ejemplo, consideremos un sistema bancario distribuido en el que visualizamos los objetos de la cuenta en una \textit{sopa}, es decir, en un conjunto múltiple o bolsa de objetos y mensajes. Dichos objetos y mensajes pueden \textit{flotar} en la sopa distribuida y pueden interactuar localmente entre sí de acuerdo con reglas de reescritura específicas.

De esta forma, podemos representar una cuenta bancaria como una estructura similar a un registro con el nombre o etiqueta del objeto, su nombre de clase cuenta (\texttt{Account}) y un atributo para el balance (\texttt{bal}) que se corresponde con un número natural. Los siguientes son dos objetos de cuentas diferentes en esta notación:

\begin{lstlisting}[language=Maude]
	< 'A-001 : Account | bal : 200 >
	< 'A-002 : Account | bal : 150 >
\end{lstlisting}
\medskip


Las cuentas se pueden actualizar al recibir diferentes mensajes y cambiar su estado en consecuencia.
Por ejemplo, podemos tener mensajes de débito y crédito, como:

\begin{lstlisting}[language=Maude]
	credit('A-002, 50)
	debit('A-001, 25)
\end{lstlisting}
\medskip

\noindent
Podemos pensar en la sopa como la yuxtaposición de objetos y mensajes con sintaxis vacía.
Por ejemplo, los dos objetos y dos mensajes anteriores forman la siguiente sopa:

\begin{lstlisting}[language=Maude]
	< 'A-001 : Account | bal : 200 >
	< 'A-002 : Account | bal : 150 >
	credit('A-002, 50)
	debit('A-001, 25)
\end{lstlisting}
\medskip

En una sopa, el orden de los objetos y mensajes es irrelevante. Las reglas de interacción local para cuentas de crédito y débito se expresan en Maude mediante las reglas de reescritura:

\begin{lstlisting}[language=Maude]
	var I : Qid .
	vars N M : Nat .

	rl < I : Account | bal : M > credit(I, N)
	=> < I : Account | bal : (M + N) > .

	crl < I : Account | bal : M > debit(I, N)
	=> < I : Account | bal : (M - N) >
	    if M >= N .
\end{lstlisting}
\medskip

\noindent
donde las reglas se introducen con la palabra clave \texttt{rl} y las reglas condicionales con la palabra clave \texttt{crl}, como la regla anterior para débito que requiere que la cuenta tenga fondos suficientes.

Es importante tener en cuenta que estas reglas no son ecuaciones, son reglas de transición locales de un sistema bancario distribuido. Se pueden aplicar simultáneamente a diferentes fragmentos de la sopa.
Por ejemplo, aplicando ambas reglas a la sopa anterior obtenemos un nuevo estado distribuido:

\begin{lstlisting}[language=Maude]
	< 'A-001 : Account | bal : 175 >
	< 'A-002 : Account | bal : 200 >
\end{lstlisting}
\medskip

\noindent
Hay que tener en cuenta que la reescritura realizada es una reescritura de varios conjuntos, de modo que, independientemente de dónde se coloquen los objetos de la cuenta y los mensajes en la sopa, siempre se pueden unir y reescribir si se aplica una regla.

En Maude, esta especificación corresponde a la parte ecuacional del programa, donde declaramos que el operador de unión de conjuntos múltiples con sintaxis vacía satisface las ecuaciones de asociatividad y commutatividad:

\begin{lstlisting}[language=Maude]
	X (Y Z) = (X Y) Z
	X Y = Y X
\end{lstlisting}
\medskip

\noindent
Esto no se hace dando explícitamente las ecuaciones anteriores. En su lugar, se declara el operador de unión de conjuntos múltiples con los atributos de ecuación \texttt{assoc} y \texttt{comm}, donde \texttt{Configuration} denota los conjuntos múltiples o sopas de objetos y mensajes:

\begin{lstlisting}[language=Maude]
	op __ : Configuration Configuration -> Configuration [assoc comm] .
\end{lstlisting}
\medskip

Luego, Maude utiliza esta información para generar un algoritmo de coincidencia de conjuntos múltiples (\textit{multiset matching algorithm}), donde el operador de unión de múltiples conjuntos se empareja módulo asociatividad y commutatividad. Por tanto, un programa que contiene estas reglas de reescritura es intuitivamente muy simple y tiene una semántica de reescritura sencilla.
\medskip

Por supuesto, los sistemas especificados por estas reglas pueden ser altamente concurrentes y no deterministas; es decir, a diferencia de las ecuaciones, no se supone que todas las secuencias de reescritura puedan conducir al mismo resultado.
\smallskip

Por ejemplo, dependiendo del orden en que se hayan tramitado los mensajes de débito o crédito, la cuenta bancaria puede terminar en estados bastante diferentes, ya que la regla de débito solo se puede aplicar si el saldo de la cuenta es lo suficientemente grande.
\smallskip

Además, algunos sistemas pueden no tener estados finales: su objetivo puede ser participar continuamente en interacciones con su entorno como sistemas reactivos.



\subsection{Reflexión en Maude}

Una característica muy importante de Maude es la reflexión. Intuitivamente, significa que los programas de Maude se pueden metarrepresentar como datos, que luego se pueden manipular y transformar mediante funciones apropiadas~\citep{maude30}.
\smallskip

También significa que existe una conexión causal sistemática entre los propios módulos de Maude y sus metarrepresentaciones, en el sentido de que primero podemos realizar un cálculo en un módulo y luego metarrepresentar su resultado, o equivalentemente podemos primero metarrepresentar el módulo y su estado inicial y luego realizar todo el cálculo en el metanivel.
\smallskip

El proceso de metarrepresentación en sí mismo puede repetirse dando lugar a una torre de reflexión muy útil. Gracias a la lógica de la semántica de Maude, esta torre es una forma precisa de reflexión lógica con una semántica bien definida.
\bigskip


Dado que las reglas de reescritura de un módulo de sistema pueden ser altamente no deterministas, puede haber muchas formas posibles de aplicarlas, lo que lleva a resultados bastante diferentes. En un sistema de objetos distribuidos, esto puede ser solo parte de la vida: siempre que se respeten algunos supuestos de equidad, cualquier ejecución simultánea puede ser aceptable.
\smallskip

La ejecución secuencial de Maude admite dos estrategias diferentes de ejecución \textit{justa} de forma integrada a través de sus comandos \texttt{rewrite} y \texttt{frewrite}. 
Si queremos utilizar una estrategia diferente para una aplicación determinada, entonces debemos ejecutar los módulos de Maude en el metanivel con estrategias internas definidas por el usuario.

Las estrategias internas se pueden definir reescribiendo reglas en un módulo de metanivel que pueden guiar la aplicación, posiblemente no determinista, de las reglas en el módulo dado a nivel de objeto. Este proceso puede repetirse en la torre de reflexión, es decir, podríamos definir meta-estrategias, meta-meta-estrategias, etc.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Metaintérprete de Maude}\label{MI}

El módulo \texttt{META-LEVEL} es puramente funcional. Esto se debe a que todas sus funciones de descenso son deterministas, aunque puedan manipular entidades intrínsecamente no deterministas como las teorías de reescritura.
%
Por ejemplo, la función descendente de \texttt{metaSearch} con un límite de, por ejemplo 3, es totalmente determinista, ya que dadas las metarepresentaciones $\bar{\mathcal R}$ del módulo del sistema deseado y $\bar{t}$ del término inicial más el límite 3, el resultado obtenido por \texttt{search} para $\mathcal{R}$, $t$ y $3$ a nivel de objeto, y por lo tanto por \texttt{metaSearch} en metanivel, se determina de manera única~\citep{maude30}.
\smallskip

Aunque \texttt{META-LEVEL} es muy potente, su naturaleza puramente funcional significa que no tiene noción de estado. Por lo tanto, las aplicaciones reflexivas en las que la interacción del usuario en un modo de cambio de estado es esencial requieren el uso de \texttt{META-LEVEL} en el contexto de las características adicionales que apoyan dicha interacción.

La característica de los metaintérpretes de Maude hace posible tipos muy flexibles de interacciones reflexivas en las que los intérpretes de Maude están encapsulados como objetos externos y pueden interactuar reflexivamente tanto con otros intérpretes como con otros objetos externos, incluido el usuario.
\medskip


Conceptualmente, un metaintérprete es un objeto externo que es un intérprete independiente de Maude, con bases de datos de módulos y vistas, que envía y recibe mensajes. El módulo \texttt{META-INTERPRETER} del archivo \texttt{meta-interpreter.maude} contiene comandos y mensajes de respuesta que cubren casi la totalidad del intérprete Maude.
Por ejemplo, puede ser construido para insertar o mostrar módulos y vistas, o realizar cálculos en un módulo con nombre.

Como respuesta, el metaintérprete responde con mensajes de reconocimiento de las operaciones realizadas o que contienen resultados. Los metaintérpretes pueden crearse y destruirse según sea necesario, y como un metaintérprete es un intérprete completo de Maude, puede albergar a los propios metaintérpretes y así sucesivamente en una torre de reflexión. Además, el módulo funcional original de \texttt{META-LEVEL} puede ser usado por sí mismo desde el interior de un metaintérprete después de ser insertado.

Internamente, las tripas de la implementación del intérprete Maude están encapsuladas en una clase \texttt{C++} llamada \texttt{Interpreter} y el intérprete de alto nivel con el que se interactúa en la línea de comandos es una instancia de esta clase junto con una pequeña cantidad de código de cola que le permite comunicarse a través de los flujos de E/S estándar. Los metaintérpretes también son instancias de esta clase, con una pequeña cantidad de código adjunto que les permite intercambiar mensajes con un contexto de ejecución de reescritura orientado a objetos. Actualmente, tanto el intérprete a nivel de objeto como cualquier metaintérprete existente ejecutan todos el mismo proceso en un solo hilo, y el flujo de control se gestiona a través del mecanismo de reescritura orientado a objetos.

La metarrepresentación de términos, módulos y puntos de vista se comparte con el módulo funcional \texttt{META-LEVEL}. La API para los metaintérpretes definida en el módulo \texttt{META-INTERPRETER} incluye varios tipos y constructores, un identificador de objeto integrado \texttt{interpreterManager} y una gran colección de comandos y mensajes de respuesta.

En el módulo \texttt{META-INTERPRETER} todos los mensajes siguen el formato estándar de los mensajes Maude, siendo los dos primeros argumentos los identificadores de objeto del objetivo y del remitente.
El identificador de objeto \texttt{interpreterManager} se refiere a un objeto externo especial que se encarga de crear nuevos metaintérpretes en el contexto de ejecución actual. Estos metaintérpretes tienen identificadores de objeto de la forma \texttt{interpreter(}$n$\texttt{)} para cualquier número natural $n$.



\subsection{Ejemplo de las muñecas rusas}

Con este breve ejemplo del módulo \texttt{RUSSIAN-DOLLS} tomado de ~\citet{maude30} se comprueba la flexibilidad y generalidad de los metaintérpretes. Este realiza un cálculo en un metaintérprete que a su vez existe en una torre de metaintérpretes anidada a una profundidad definible por el usuario. Tan solo requiere dos ecuaciones y dos reglas.
 
\begin{lstlisting}[language=Maude,caption={Módulo \texttt{RUSSIAN-DOLLS}},label=lst:Russian]
 mod RUSSIAN-DOLLS is
   extending META-INTERPRETER .
   
   op me : -> Oid .
   op User : -> Cid .
   op depth:_ : Nat -> Attribute .
   op computation:_ : Term -> Attribute .

   vars X Y Z : Oid .
   var AS : AttributeSet .
   var N : Nat .
   var T : Term .

   op newMetaState : Nat Term -> Term .
   eq newMetaState(0, T) = T .
   eq newMetaState(s N, T)
     = upTerm( <>
        < me : User | depth: N, computation: T >
        createInterpreter(interpreterManager, me, none)) .

   rl < X : User | AS >
      createdInterpreter(X, Y, Z)
   => < X : User | AS >
      insertModule(Z, X, upModule('RUSSIAN-DOLLS, true)) .

   rl < X : User | depth: N, computation: T, AS >
      insertedModule(X, Y)
   => < X : User | AS >
      erewriteTerm(Y, X, unbounded, 1, 'RUSSIAN-DOLLS, newMetaState(N, T)) .
endm
\end{lstlisting}

El estado visible del cálculo reside en un objeto de identificador \texttt{me} de la clase \texttt{Oid} y \texttt{User} de la clase \texttt{Cid}. El objeto tiene dos valores en sus respectivos atributos: la profundidad (\texttt{depth}) del metaintérprete, que se registra como \texttt{Nat}, con \texttt{0} como nivel superior, y el cómputo (\texttt{computation}) a realizar, que se registra como \texttt{Term}.
\smallskip

El operador \texttt{newMetaState} toma una profundidad y un metatérmino para evaluar. Si la profundidad es cero, entonces simplemente devuelve el metatérmino como el nuevo \texttt{metastate}; de lo contrario, se crea una nueva configuración, que consiste en un portal (necesario para reescribir con objetos externos, para localizar dónde salen y entran en la configuración los mensajes intercambiados con los objetos externos), el objeto visible por el usuario que contiene la profundidad disminuida y el cálculo, y un mensaje dirigido al objeto externo \texttt{interpreterManager}, solicitando la creación de un nuevo metaintérprete.
Esta configuración se eleva al metanivel utilizando el operador \texttt{upTerm} importado del metanivel funcional.
\smallskip

La primera regla del módulo \texttt{RUSSIAN-DOLLS} maneja el mensaje: \texttt{createInterpreter} del \texttt{interpreterManager}, que recibe como argumento el identificador de objeto del metaintérprete recién creado. Utiliza la función \texttt{upModule} para elevar su propio módulo, \texttt{RUSSIAN-DOLLS}, al metanivel y envía una petición para insertar este meta-módulo en el nuevo metaintérprete.

La segunda regla maneja el mensaje \texttt{insertedModule} del nuevo metaintérprete. Llama al operador \texttt{newMetaState} para crear un nuevo metaestado y luego envía una solicitud al nuevo metaintérprete para realizar un número no acotado de reescrituras, con soporte de objetos externos y una reescritura por ubicación por recorrido en la copia de metanivel del módulo \texttt{RUSSIAN-DOLLS} que se acaba de insertar.

Comenzamos el cálculo con el comando de \texttt{erewrite} en una configuración que consiste en un portal, un objeto de usuario y un mensaje \texttt{createInterpreter}. 

En este caso el objeto de usuario tiene como atributos la profundidad \texttt{0} y el cómputo a evaluar de la metarrepresentación de \texttt{2 + 2}:

\begin{lstlisting}[language=Maude]
	Maude> erewrite
	  <>
	  < me : User | depth: 0, computation: ('_+_['s_^2['0.Zero], 's_^2['0.Zero]])>
	  createInterpreter(interpreterManager, me, none) .

	result Configuration:
	<>
	< me : User | none >
	erewroteTerm(me, interpreter(0), 1, 's_^4['0.Zero], 'NzNat)
\end{lstlisting}
\medskip

Como se puede ver en \texttt{result Configuration}, el resultado es \texttt{Zero} que es la evaluación de la meta-representación del cálculo directamente en un metaintérprete, sin anidar.
\medskip

Para la siguiente ejecución realizaremos el mismo cálculo pero cambiaremos la profundidad a~\texttt{1}:

\begin{lstlisting}[language=Maude]
	Maude> erewrite
	  <>
	  < me : User | depth: 1, computation: ('_+_ ['s_^2['0.Zero],'s_^2['0.Zero]])>
	  createInterpreter(interpreterManager, me, none) .

	result Configuration:
	<>
	< me : User | none >
	erewroteTerm(me, interpreter(0), 5,
	    '__['<>.Portal,
	        '<_:_|_>['me.Oid,'User.Cid,'none.AttributeSet],
	        'erewroteTerm['me.Oid,'interpreter['0.Zero],'s_['0.Zero],
	          '_`[_`][''s_^4.Sort,''0.Zero.Constant],''NzNat.Sort]], 'Configuration)
\end{lstlisting}
\medskip

Pasando a una profundidad de \texttt{1} resulta un cambio y se transforma en un metaintérprete anidado.
El mensaje de respuesta de nivel superior \texttt{erewroteTerm(...)} contiene un resultado que es una metaconfiguración, que contiene el metamensaje de respuesta del metaintérprete interno.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Soft Sets}\label{SS}
Muchos problemas de la vida real requieren el uso de datos imprecisos o inciertos. Su análisis debe implicar la aplicación de principios matemáticos capaces de captar estas características. La teoría de conjuntos difusos (fuzzy sets) supuso un cambio paradigmático en las matemáticas al permitir un grado de pertenencia parcial. Existe una vasta literatura sobre los conjuntos difusos y sus aplicaciones desde la publicación del artículo de~\citet{Zadeh}. 

De las generalizaciones de los fuzzy sets nos interesa especialmente la aplicación de la teoría de los conjuntos blandos (soft sets) y sus extensiones a los problemas de la toma de decisiones.
Los soft sets fueron introducidos por \citep{Molodtsov99}. 
Algunas referencias relevantes del desarrollo de su teoría se deben a: \citet{AktasCagman}, \citet{Alcantud2016IJAR}, \citet{AliFengLiuMinShabir} y \citet{MajiBR03}.
\citet{AliMahmood} definen soft sets ordenados en red para situaciones en las que existe algún orden entre los elementos del conjunto de parámetros. \citet{QinMengPeiXu} combinan los conjuntos de intervalos y los soft sets y \citet{Zhang} estudia los interval soft sets y sus aplicaciones. \citet{MajiBR01} introducen los fuzzy soft sets. \citet{WangLiChen} introducen los hesitant fuzzy soft sets. \citet{Hanetal}, \citet{QinMaHerawanZain}, y \citet{ZouXiao} se ocupan de los soft sets incompletos. También hay interesantes modelos híbridos en la literatura reciente.


\subsection{Soft sets incompletos}

Se adopta la descripción y terminología habitual para los soft sets y sus extensiones: el conjunto $U$ denota el universo de objetos y el conjunto $E$ denota el conjunto universal de parámetros.

\begin{definition}[\citet{Molodtsov99}]
Un par $(F,A)$ es un soft set sobre $U$ cuando $A\subseteq E$ y $F: A \longrightarrow {\cal P}(U)$, donde ${\cal P}(U)$ denota el conjunto de todos los subconjuntos de $U$.
\end{definition}

Un soft set sobre $U$ es considerado como una familia de subconjuntos parametrizados del universo $U$, siendo el conjunto $A$ los parámetros. Para cada parámetro $e\in A$, $F(e)$ es el subconjunto de $U$ aproximado por $e$ o el conjunto de elementos $e$-aproximados del soft set. Muchos investigadores han desarrollado esta noción y definen otros conceptos relacionados~\citep{MajiBR03,FengLi}.
Para modelar situaciones cada vez más generales, se ha propuesto la siguiente definición de soft sets incompletos.



\begin{definition}[\citet{Hanetal}]\label{def:SSincompl}
Un par $(F,A)$ es un \textit{soft set incompleto} sobre $U$ cuando $A\subseteq E$ y $F: A \longrightarrow \{0, 1, *\}^U$, donde $\{0, 1, *\}^U$ es el conjunto de todas las funciones de $U$ a $\, \{0, 1, *\}$. 
\end{definition}

Obviamente, todo soft set puede considerarse un soft set incompleto. El símbolo $*$ en la definición~\ref{def:SSincompl} permite capturar la \textit{falta de información}: cuando $F(e)(u)=*$ interpretamos que se desconoce si $u$ pertenece al subconjunto de $U$ aproximado por $e$. Como en el caso de los soft sets, cuando $F(e)(u)=1$ (resp., $F(e)(u)=0$), interpretamos que $u$ pertenece (resp., no pertenece) al subconjunto de $U$ aproximado por $e$. 
\smallskip

Cuando los conjuntos $U$ y $A$ son finitos, los soft sets y los soft sets incompletos pueden representarse por matrices o en forma tabular. Las filas se corresponden con objetos en $U$ y las columnas se corresponden con parámetros en $A$. En el caso de un soft set, estas representaciones son binarias (es decir, todos los elementos o celdas son $0$ ó $1$).

El siguiente ejemplo de la práctica real ilustra un soft set incompleto. Después lo utilizamos para explicar los fundamentos de toma de decisiones en términos prácticos. 

\begin{ejemplo}\label{eG1}
Sea $U= \{h_1, h_2, h_3\}$ el universo de casas y $E_0= \{e_1, e_2, e_3, e_4\}$ el conjunto de parámetros (atributos o características de la casa). La siguiente información define un soft set incompleto $(F_0, E_0)$: 
\begin{enumerate}
\item[(a)] $h_1\in F_0(e_1) \cap F_0(e_3) $ y $h_1\not\in F_0(e_4) $, pero se desconoce si $h_1\in F_0(e_2)$ o no.
\item[(b)] $h_2\in F_0(e_2)$  y $h_2\not\in F_0(e_3) \cup F_0(e_4) $, pero se desconoce si $h_2\in F_0(e_1)$ o no.
\item[(c)] $h_3\in F_0(e_1) \cap F_0(e_4)$ and $h_3\not\in F_0(e_2) \cup F_0(e_3) $.
\item[(d)] $h_4\notin F_0(e_1) \cup F_0(e_2) \cup F_0(e_4)$, pero se desconoce si $h_4\in F_0(e_3)$ o no.
\end{enumerate}
\end{ejemplo}

La tabla~\ref{tableG1} captura la información que define $(F_0, E_0)$.
De esta forma, se obtiene la representación tabular del soft set incompleto $(F_0, E_0)$.

\begin{table}[h!]
\centerline{
			%\resizebox{.5\textwidth}{!}{
\begin{tabular}[t]{rcccccc} 
\hline
  & $e_{1}$ & $e_{2}$ & $e_{3}$& $e_{4}$ \\
\hline
 $h_{1}$  &  $1$  &  $*$ & $1$ & $0$ \\
 $h_{2}$  &  $*$ &  $1$ & $0$ &  $0$\\
 $h_{3}$  &  $1$ &  $0$ & $0$ &  $1$\\
 $h_{4}$  &  $0$ &  $0$ & $*$ &  $0$\\
 \hline
  \end{tabular} 
}
		%	}
\caption[Representación tabular del soft set incompleto]{Representación tabular del soft set incompleto $(F_0, E_0)$ definido en el ejemplo~\ref{eG1}.}
\label{tableG1}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Toma de decisiones con soft sets}

\citet{MajiBR02} fueron pioneros en la toma de decisiones basadas en soft sets. Establecieron el criterio de que un objeto puede ser seleccionado si maximiza el valor de elección del problema. En relación con esto, \citet{ZouXiao} argumentaron que en el proceso de recopilación de datos puede haber datos desconocidos, imprecisos o inexistentes. Por lo tanto, se deben tener en cuenta los soft sets estándar bajo formación incompleta, lo que exige la inspección de soft sets incompletos. 

Cuando un soft set $(F, A)$ se representa en forma matricial a través de la matriz $(t_{ij})_{k\times l}$, donde $k$ y $l$ son los cardinales de $U$ y $A$ respectivamente, entonces el valor de elección (o \emph{choice value}) de un objeto $h_i\in U$ es $c_i = \sum _{j} t_{ij}$. Se hace una elección adecuada cuando el objeto seleccionado $h_k$ verifica $c_k=\max _{i}c_i$. En otras palabras, los objetos que maximizan el valor de elección son los resultados satisfactorios de este problema de decisión.


En lo que respecta a la toma de decisiones incompleta basada en soft sets, los enfoques más utilizados son los de \citet{ZouXiao}, \citet{QinMaHerawanZain}, \citet{Hanetal} y \citet{AlcantudSantos17}. Examinemos las ideas de sus métodos:

\begin{enumerate}
\item[(a)] \citet{ZouXiao} iniciaron el análisis de soft sets y fuzzy soft sets bajo información incompleta. En el primer caso, proponen calcular todos los valores de elección posibles para cada objeto, y luego calcular sus respectivos valores de decisión $d_{i}$ por el método del promedio ponderado. Para ello, el peso de cada valor de elección posible se calcula con la información completa existente. En particular, proponen algunos indicadores sencillos que pueden utilizarse eventualmente para priorizar las alternativas, a saber, $c_{i(0)}$ (el valor de elección si se supone que todos los datos que faltan son $0$), $c_{i(1)}$ (el valor de elección si se supone que todos los datos que faltan son $1$) y $d_{i-p}$ (el valor de elección corresponde a $(c_{i(0)}+c_{i(1)})/2$). 

\item[(b)]  Inspirándose en el enfoque de análisis de datos de Zou y Xiao, \citet{QinMaHerawanZain} proponen una nueva forma de completar los datos que faltan en un soft set incompleto. Para ello, introducen la relación entre los parámetros. Así pues, dan prioridad a la asociación entre parámetros antes que a la probabilidad de que aparezcan objetos en $F(e_i)$. De esta manera, adjuntan un soft set completo con cualquier soft set incompleto. Sin embargo, el procedimiento de \citet{QinMaHerawanZain} presupone que hay asociaciones entre algunos de los parámetros. En su propuesta, cuando no se alcanza un umbral dado exógenamente, los datos se rellenan según el enfoque de Zou y Xiao. 

Qin et al.~indican que su procedimiento puede utilizarse para implementar aplicaciones que impliquen soft sets incompletos, pero no hacen ninguna declaración explícita en cuanto a la toma de decisiones. No obstante, parece apropiado complementar su procedimiento de llenado con una priorización de los objetos de acuerdo con sus valores de elección $Q_i$, como es frecuente en la toma de decisiones basada en los soft sets.

\item[(c)]  \citet{Hanetal} explican que su método es bueno cuando los objetos en $U$ están relacionados entre sí. Estos autores desarrollan y comparan varios criterios de obtención para la toma de decisiones de soft sets incompletos que se generan por intersección restringida. 

\item[(d)] Por último, \citet{AlcantudSantos17} proponen considerar todas las formas posibles de ``completar'' un soft set incompleto y tomar la decisión a partir de estas soluciones completadas. Este sistema es apropiado cuando no se tiene información a priori sobre la relación entre los objetos y los parámetros.

Para explicar la idea de este método, la aplicamos sobre el ejemplo~\ref{eG1} y obtenemos los valores de elección $s_i$ de cada opción. Si se tienen en cuenta todas las posibilidades, en última instancia uno de las cuatro tablas representadas en la tabla~\ref{tableG2} contiene la información completa que se necesita para tomar la decisión. 
En esta tabla hemos eliminado el objeto $h_4$ debido al cribado de dominación previo que se explica a continuación.
Como no sabemos cuál será la correcta, debemos asumir que todas estas tablas son equiparables según el principio de indiferencia de Laplace. Por lo tanto, es sensato calcular qué objetos deben ser seleccionados de acuerdo con la toma de decisiones en cada uno de estos casos, y luego seleccionar el objeto que sea óptimo en la mayoría de los casos.
\end{enumerate}


\begin{table}[h!]
\centerline{
\begin{tabular}[t]{lllllr} 
& \multicolumn{4}{c}{$C_{v_1}$ matrix} \\
\cline{2-5}
  & $e_{1}$ & $e_{2}$ & $e_{3}$& $e_{4}$ & $c_{i}$\\
\hline
 $h_{1}$  &  $1$  &  $0$ & $1$ & $0$ & $2$\\
 $h_{2}$  &  $0$ &  $1$ & $0$ &  $0$ & $1$\\
 $h_{3}$  &  $1$ &  $0$ & $0$ &  $1$ & $2$\\
\hline
 \end{tabular}    \qquad
\begin{tabular}[t]{lllllr} 
& \multicolumn{4}{c}{$C_{v_2}$ matrix} \\
\cline{2-5}
  & $e_{1}$ & $e_{2}$ & $e_{3}$& $e_{4}$ & $c_{i}$\\
\hline
 $h_{1}$  &  $1$  &  $0$ & $1$ & $0$ & $2$\\
 $h_{2}$  &  $1$ &  $1$ & $0$ &  $0$& $2$\\
 $h_{3}$  &  $1$ &  $0$ & $0$ &  $1$& $2$\\
\hline
 \end{tabular}
} \vspace{0.5cm}

\centerline{
\begin{tabular}[t]{lllllr} 
& \multicolumn{4}{c}{$C_{v_3}$ matrix} \\
\cline{2-5}  
& $e_{1}$ & $e_{2}$ & $e_{3}$& $e_{4}$ & $c_{i}$\\
\hline
 $h_{1}$  &  $1$  &  $1$ & $1$ & $0$ & $3$\\
 $h_{2}$  &  $0$ &  $1$ & $0$ &  $0$& $1$\\
 $h_{3}$  &  $1$ &  $0$ & $0$ &  $1$& $2$\\
\hline
\end{tabular}    \qquad
\begin{tabular}[t]{lllllr} 
& \multicolumn{4}{c}{$C_{v_4}$ matrix} \\
\cline{2-5}  
& $e_{1}$ & $e_{2}$ & $e_{3}$& $e_{4}$ & $c_{i}$\\
\hline
 $h_{1}$  &  $1$  &  $1$ & $1$ & $0$ & $3$\\
 $h_{2}$  &  $1$ &  $1$ & $0$ &  $0$& $2$\\
 $h_{3}$  &  $1$ &  $0$ & $0$ &  $1$& $2$\\
\hline
 \end{tabular} 
 }
\vspace{0.3cm}
\caption[Tablas completadas para un soft set incompleto]{Las cuatro tablas completadas para el soft set incompleto $(F_0, E_0)$ según el paso 4 de nuestro algoritmo, con los respectivos valores de elección para cada alternativa.}
\label{tableG2}
\end{table}


El investigador puede llevar a cabo una operación de cribado antes de seleccionar una opción final. En primer lugar, calculamos el valor máximo $c_0$ de todos los valores de elección $c_{j(0)}$ a través de las opciones $u_j$. Si este valor es estrictamente mayor que el valor de elección $c_{k(1)}$ de una alternativa $u_k$, esta alternativa puede ser eliminada de la matriz/tabla inicial. La razón es que si se supone que todos los datos que faltan para el $u_k$ son $1$, hay otra opción~$i$ que verifica que cuando todos los datos que faltan para $u_i$ se suponen que son~$0$, la opción~$i$ sigue teniendo un valor de elección mayor que la opción $k$. Este argumento sugiere la siguiente definición de dominancia entre opciones.

\begin{definition}\label{dDom}
Sea $(F,A)$ un soft set incompleto sobre $U$. Una opción $i$ domina una opción $k$ cuando $c_{k(1)} < c_{i(0)}$. 
\end{definition}

Claramente, si empleamos cualquier solución basada en el valor de la elección, podemos descartar libremente las opciones dominadas. Por ejemplo, si utilizamos $d_j$, $c_{j(0)}$, $c_{j(1)}$ ó $d_{j-p}$ como indicador de cualquier opción $j$, la opción $k$ no puede maximizar el indicador seleccionado cuando la opción $i$ lo domina. Esta simplificación es básicamente intrascendente en el caso de las soluciones de Zou y Xiao, sin embargo, podemos aplicarla en otros algoritmos computacionalmente costosos para reducir los cálculos.
\smallskip

Siguiendo con el ejemplo~\ref{eG1}, observamos que las casas $1$ y $3$ dominan la casa $4$, por lo que $h_4$ se elimina y queda una tabla de $3\times 4$. En dicha tabla recortada tenemos $w = 2$, y enumeramos las celdas con valor $*$ como $((1,2),(2,1))$. 

Por cada $v\in  \{0, 1\}^w =  \{v_1=(0,0), v_2=(0,1), v_3=(1,0), v_4=(1,1)\}$ surge una tabla factible completada. Estas cuatro tablas están representadas en la tabla~\ref{tableG2}, junto con los valores de elección de las casas de cada tabla. Observamos que $h_1$ adjunta el valor de elección más alto en todas estas cuatro tablas, $h_2$ adjunta el valor de elección más alto sólo en $C_{v_2}$, y $h_3$ adjunta el valor de elección más alto exactamente en $C_{v_1}$ y $C_{v_2}$. 
\medskip

La tabla~\ref{tableG3} contiene los indicadores de las propuestas de solución que hemos mencionado aplicados al ejemplo~\ref{eG1}. También se representan las alternativas óptimas para cada procedimiento. Además, observe que el hecho de que las casas $1$ y $3$ dominen la casa $4$ se deriva de la tabla~\ref{tableG3}, al comparar el máximo de la columna $c_{i(0)}$---que se alcanza en $1$ y~$3$---y los valores de la columna $c_{i(1)}$ que son estrictamente menores que dicho máximo. 

\begin{table}[h!]
\centerline{
			%\resizebox{.5\textwidth}{!}{
\begin{tabular}[t]{rcccccc} 
\hline
   & $s_{i}$ & $d_{i}$ & $d_{i-p}$& $c_{i(0)}$ &  $c_{i(1)}$  &  $Q_i$   \\
\hline
 $h_{1}$  &  $1.00$ &  $2.50$ & $2.50$ &  $2$  & $3$ & 3 \\
 $h_{2}$  &  $0.25$ &  $2.00$ & $1.50$ &  $1$  & $2$ & 1 \\
 $h_{3}$  &  $0.50$ &  $2.00$ & $2.00$ &  $2$  & $2$ & 2 \\ 
 $h_{4}$  &  $0$ &  $ 0.33 $ & $0.5$ &  $0$  & $1$ & 1 \\
 \hline 
 \footnotesize \'Optimo  &  $\{h_1\}$ &  $\{h_1\}$ & $\{h_1\}$ &  $\{h_1, h_3\} $ & $\{h_1\}$ & $\{h_1\} $ \\ 
\hline
  \end{tabular} 
}
\caption[Soluciones para el problema representado por $(F_0, E_0)$]{Soluciones para el problema representado por $(F_0, E_0)$ en ejemplo~\ref{eG1} según varios indicadores.}
\label{tableG3}
\end{table}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Sistemas Biológicos Simbólicos y Pathway Logic}\label{PL}

El lenguaje Maude proporciona numerosas herramientas de análisis para teorías de reescritura: cálculo de reescrituras, búsqueda en amplitud, verificación de modelos o model checking en la lógica temporal lineal, demostrador inductivo de teoremas y muchos otros. Con la utilización de estas funcionalidades es posible estudiar el comportamiento de los sistema biológicos, para comprobar si es posible alcanzar un cierto estado desde el estado inicial y analizar si el sistema verifica algunas propiedades temporales.

La idea de transición entre estados permite modelar los sistemas biológicos con la lógica de reescritura de una manera muy natural: mientras que las células son un conjunto de multiconjuntos que representan las diferentes componentes que aparecen en una célula real, las reacciones bioquímicas se representan por medio de reglas de reescritura~\citep{DBLP:conf/sfm/2008}.

Pathway Logic es una técnica de análisis cualitativo basada en la lógica de reescritura~\citep{sfm/Talcott08}. Pathway Logic se utiliza para modelar y analizar procesos biológicos, como la transducción de señales, las redes metabólicas o la señalización de células del sistema inmunológico. Los modelos de Pathway Logic se representan y analizan con la utilización del sistema Maude~\citep{maude2007,DBLP:conf/bibm/Talcott16}. Los modelos pueden analizarse directamente por ejecución, búsqueda y verificación de modelos~\citep{DBLP:journals/tcsb/TalcottD06,csb/TalcottEKLL03,DBLP:conf/cmsb/TalcottK17}. Actualmente las capacidades de Pathway Logic incluyen:

\begin{enumerate}
\item Modelos con diferentes niveles de detalle. Las moléculas biológicas, sus estados, sus localizaciones y sus roles en los procesos moleculares o celulares pueden ser modelados con diferentes niveles de abstracción. Por ejemplo, una proteína de señalización compleja puede ser modelada ya sea de acuerdo a un estado general, a sus modificaciones postraduccionales o como un conjunto de dominios funcionales de la proteína y sus interacciones internas o externas~\citep{DBLP:journals/entcs/EkerKLLT02}.
\item Rutas generadas dinámicamente con el uso de búsquedas y verificación de modelos. Dada una especificación de un sistema concurrente, esta se puede: ejecutar para encontrar un comportamiento posible; utilizar la búsqueda para comprobar si se puede alcanzar un estado que cumpla una condición determinada; o la verificación del modelo para ver si se satisface una propiedad temporal; y, cuando no se cumple la propiedad, se puede mostrar el contraejemplo~\citep{DBLP:conf/csb/KnappBELPTL05}. 
\item Transformación a redes de Petri para análisis y visualización. Pathway Logic Assistant es un software Java que implementa una herramienta gráfica de Pathway Logic. Pathway Logic Assistant proporciona una representación visual interactiva de los modelos de Pathway Logic y, entre otras, facilita las siguientes tareas: muestra la red de reacciones de señalización para una determinada placa de preparación (o dish); formula y envía consultas para encontrar y comparar rutas; o calcula y muestra la subred descendente de una o más proteínas~\citep{talcott-dill-05cmsb}. Dado un estado inicial, Pathway Logic Assistant selecciona las reglas correspondientes del conjunto de reglas y representa la red de reacciones resultante como una red de Petri. De esta forma, se consigue una representación gráfica natural y se consiguen algoritmos eficientes para responder a las consultas.
\end{enumerate}


\subsection{Modelos en Pathway Logic: ecuaciones}
Para ilustrar cómo Pathway Logic puede tratar las rutas de señalización, se muestra a continuación un modelo abreviado de transducción de señales intracelulares.
Una base de conocimiento formal contendrá la información sobre los cambios que ocurren en las proteínas dentro de una célula en respuesta a la exposición a ligandos receptores, sustancias químicas y otros elementos.

TGFB1 (Factor de crecimiento transformante beta 1) es uno de los modelos implementados en Pathway Logic. El modelo TGFB1 contiene un total de 57 reglas y 968 datums. La evidencia experimental de cada regla se suministra en forma de datums. Cada datum representa el resultado de un experimento publicado en una revista especializada~\citep{sfm/Talcott08}. Las reglas y las evidencias forman parte del modelo de estímulos que se puede descargar del sitio web de Pathway Logic (\url{http://pl.csl.sri.com}). 

La figura~\ref{fig:tgf-b} muestra la complejidad de las reacciones que tienen lugar en la ruta de señalización TGF-$\beta$.

\begin{figure}[h!]
\centering
\includegraphics[height=11.5cm]{imagenes/tgf-b.png}
\caption[Ruta de señalización TGF-$\beta$]{Ruta de señalización TGF-$\beta$. Fuente: Cell Signaling Technology.}
\label{fig:tgf-b}
\end{figure}

Los modelos de Pathway Logic están estructurados en cuatro capas: clases y operaciones, componentes, reglas y consultas. En primer lugar, la capa de clases y operaciones declara las principales relaciones de clases y subordinación, constituye el análogo lógico de la ontología. De esta forma, analizaremos de arriba a abajo los aspectos involucrados en un modelo de Pathway Logic. Las placas de preparación o dishes se definen como envoltorios de múltiples conjuntos o términos de la clase sopa (\texttt{Soup}). Los elementos de una sopa son las diferentes partes o localizaciones de la célula con sus respectivos contenidos. En Maude, el operador de \texttt{PD} se define como:

\begin{lstlisting}[language=Maude]
  op PD : Soup -> Dish [ctor] .
\end{lstlisting}

\noindent%
De esta manera, el operador de \texttt{PD} se aplica a un conjunto múltiple de partes de la célula y se obtiene un elemento de la clase \texttt{Dish}. Por ejemplo, el siguiente código en Maude define una placa con dos localizaciones: el núcleo (\texttt{NUc}) que contiene las proteínas \texttt{Rb1}, \texttt{Myc}, y \texttt{Tp53}; y la membrana celular (\texttt{CLm}) que contiene las proteínas \texttt{EgfR} y \texttt{PIP2}:

\begin{lstlisting}[language=Maude]
  PD( {NUc | Rb1 Myc Tp53}  {CLm | EgfR PIP2} ) .
\end{lstlisting}

En un segundo nivel, se define la sopa de localizaciones:

\begin{lstlisting}[language=Maude,caption={Definición en Maude de la sopa de localizaciones},label=lst:Soup]
  sorts MtSoup Soup .
  subsort MtSoup < Soup .
  op empty : -> MtSoup [ctor] .  
  op __ : Soup Soup -> Soup [ctor assoc comm id: empty] .
\end{lstlisting}

\noindent%
Es decir, se definen las clases de \texttt{Dish} y \texttt{MtSoup} y además \texttt{MtSoup} es una subclase de la clase \texttt{Soup}. La sopa vacía se define con el operador constante \texttt{empty}. Por último, el operador \verb$__$ define un conjunto múltiple de entidades no ordenadas (en términos matemáticos, una lista asociativa y conmutativa de elementos cuyo elemento neutro es la lista vacía \texttt{empty}). Un ejemplo de un término de la clase \texttt{Soup} es:

\begin{lstlisting}[language=Maude]
  {NUc | Rb1 Myc Tp53}  {CLc | Erks Erk1}  {CLm | EgfR PIP2}
\end{lstlisting}

\noindent%
donde hay un conjunto de tres localizaciones (\texttt{NUc}, \texttt{CLc} y \texttt{CLm}) con sus respectivos contenidos. En cuanto a la definición de cada localización, se utiliza la clase \texttt{Location} para especificar los elementos en los diferentes localizaciones de la célula:

\begin{lstlisting}[language=Maude]
  op {_|_} : LocName Soup -> Location [ctor] .
\end{lstlisting}

\noindent%
El operador \verb${_|_}$ tiene dos argumentos: el identificador de la localización y su contenido (es decir, una sopa de elementos como proteínas, sustancias químicas y genes). Los diferentes elementos pueden estar contenidos en diferentes partes o ubicaciones de la célula: fuera de la célula (\texttt{XOut}), dentro o a través de la membrana celular (\texttt{CLm}), adheridos al interior de la membrana celular (\texttt{CLi}), en el citoplasma (\texttt{CLc}) y en el núcleo (\texttt{NUc}). Podemos indicar que el núcleo \texttt{NUc} contiene el gen \texttt{Tp53-gene} (la transcripción del gen está \texttt{on}) y las proteínas \texttt{Rb1}, \texttt{Myc}, \texttt{Tp53} y \texttt{NProteasome}:

\begin{lstlisting}[language=Maude]
 {NUc | [Tp53-gene - on] Rb1 Myc Tp53 NProteasome}
\end{lstlisting}
\medskip

En la definición del operador \verb${_|_}$, hemos visto que se recibe un término del tipo \texttt{Soup} como segundo argumento. En este caso, esta sopa es una lista del contenido de esa parte o localización de la célula. Finalmente, señalamos que cada uno de los elementos de una sopa puede tener modificaciones. Por ejemplo, el término \texttt{[Rac1 - GDP]} indica que la proteína \texttt{Rac1} se une al guanosín difosfato (\texttt{GDP}). 

La clase \texttt{Modification} se utiliza para representar una modificación de la proteína post-traducción (por ejemplo, activación, unión, fosforilación). Las modificaciones en Maude se aplican utilizando el operador \verb$[_-_]$.

\begin{lstlisting}[language=Maude]
  op [_-_] : Protein ModSet -> Protein  [right id: none ] .
\end{lstlisting}

\noindent%
Las modificaciones son un conjunto de modificaciones individuales que pertenecen a la clase \texttt{ModSet}. Un conjunto de modificaciones se define en Maude de forma análoga a las sopas definidas anteriormente:

\begin{lstlisting}[language=Maude,caption={Conjunto de modificaciones en Maude
},label=lst:SoupModifications]
  sorts Site  Modification ModSet .
  subsort Modification < ModSet . 
  op none : -> ModSet . 
  op __ : ModSet ModSet -> ModSet [assoc comm id: none] . 
\end{lstlisting}

Hay numerosas modificaciones posibles: \verb$acetyl!site$ (acetilado en un sitio específico), \verb$act$ (activado), \verb$degraded$ (degradado), \verb$dimer$ (dimerizado), \verb$GDP$ (ligado al GDP), \verb$GTP$ (ligado al GTP), \verb$K48ubiq$ (ligado covalentemente a la ubiquitina polimerizada mediante enlaces K48), \verb$K63ubiq$ (ligado covalentemente a la ubiquitina polimerizada mediante enlaces K63), \verb$p50$ (un producto de separación de 50kD), \verb$phos$ (fosforilado), \verb$phos!$ (fosforilado en un sitio específico), \verb$sumo$ (sumoilado), \verb$ubiq$ (ubiquitado), \verb$Yphos$ (fosforilado en tirosina), \verb$off$ (no transcribe el ARNm) y \verb$on$ (transcribe el ARNm)~\citep{DBLP:conf/bibm/Talcott16}. 

En el lenguaje Maude, cada una de estas modificaciones se define de esta manera: 

\begin{lstlisting}[language=Maude,caption={Definición de las modificaciones en Maude},label=lst:DefinitionModifications]
  op act : -> ACT [ctor metadata "((description \"activated\") (abbrev +))"] .
  op phos : -> AAMOD [ctor metadata "((term \"phosphorylated residue\")        (abbrev p))"] . 
  op ubiq : -> AAMOD [ctor metadata "((term \"ubiquitinylated on lysine\")     (abbrev ub))"] . 
  op GDP : -> SMBIND [ctor metadata "((term \"Guanosine 5'-diphosphate\")      (abbrev GDP))"] .
  op GTP : -> SMBIND [ctor metadata "((term \"Guanosine 5'-triphosphate\")     (abbrev GTP))"] .
\end{lstlisting}

\noindent%
donde \texttt{ACT}, \texttt{AAMOD}, y \texttt{SMBIND} son subclases de la clase \texttt{Modification}. En las opciones del operador, una palabra clave \texttt{metadata} permite incluir meta-información adicional sobre un modificador. 
\medskip

La figura~\ref{fig:diagramdish1} muestra una representación esquemática de una célula muy simple. Diferentes elementos aparecen en diferentes partes o localizaciones de la célula: fuera de la célula (\texttt{XOut}), dentro o a través de la membrana celular (\texttt{CLm}), adheridos al interior de la membrana celular (\texttt{CLi}), en el citoplasma (\texttt{CLc}) y en el núcleo (\texttt{NUc}). Se representan algunas proteínas: el factor de crecimiento epidérmico (\texttt{Egf}), la cinasa PI3 (\texttt{Pi3k}), la cinasa activadora ERK 1 (\texttt{Mek1}), etc. Algunas componentes aparecen con distintos modificadores: activación (\texttt{act}), fosforilación sobre la tirosina (\texttt{Yphos}), y unión al GDP (\texttt{GDP}). Esta célula se representada en Maude con el siguiente \texttt{SmallDish}:

\begin{lstlisting}[language=Maude,caption={Placa de preparación \texttt{SmallDish}},label=lst:SmallDish]
eq SmallDish = 
  PD( {XOut | Egf}  {CLi | Pi3k [Cdc42 - GDP]}
    {NUc | Rb1 Myc Tp53}
    {CLc | [Mek1 - act] [Ilk - act] Erks Erk1}
    {CLm | EgfR PIP2 [Gab1 - Yphos]}) .
\end{lstlisting}

\begin{figure}[h!]
\centering
%\vspace{-0.2in}
\includegraphics[width=10.0cm]{imagenes/cell1.png}
\caption[Representación esquemática de una célula]{Representación esquemática de una célula. Las proteínas activadas están marcadas en rojo, las fosforiladas en azul y las unidas a GDP en amarillo. Las proteínas que no tienen modificaciones se muestran en verde.}
\label{fig:diagramdish1}
\end{figure}
\medskip


Con la ayuda de Pathway Logic Assistant, la figura~\ref{fig:fig_pla} muestra la representación neta de Petri de la ruta de señalización. Los rectángulos son transiciones (reacciones bioquímicas) y los óvalos son ocurrencias (entidades biológicas) en las que las ocurrencias iniciales son más oscuras. Los reactivos de una regla son las ocurrencias conectadas a la regla por flechas desde la ocurrencia a la regla. Los productos de una regla son las ocurrencias conectadas a la regla por flechas desde la regla hasta la ocurrencia. Las flechas punteadas indican una ocurrencia que es tanto de entrada como de salida. 
%
Por ejemplo, observamos en esta figura que la proteína \texttt{Jak1} (en el citoplasma) y la proteína transmembrana \texttt{Gp130} (en la localización \texttt{GP130C}) intervienen como reactivos en la reacción/regla \texttt{1229c}. El resultado de esta reacción es que la proteína \texttt{Gp130} no cambia y \texttt{Jak1} se mueve desde el citoplasma a la ubicación de \texttt{GP130C}.

\begin{figure}[h!]
\centering
\includegraphics[height=8.5cm]{imagenes/fig_pla.png}
\caption[Pathway Logic Assistant]{Vista general de una ruta de señalización con Pathway Logic Assistant.}
\label{fig:fig_pla}
\end{figure}


Por último, detallamos la codificación completa de un ejemplo específico de la placa de preparación \texttt{Tgfb1Dish}: 

\begin{lstlisting}[language=Maude,caption={Dish \texttt{Tgfb1Dish}},label=lst:DishTgfb1Dish]
  op Tgfb1Dish : -> Dish .
  eq Tgfb1Dish = PD( {XOut | Tgfb1} {Tgfb1RC | TgfbR1 TgfbR2} {CLo | empty} 
    {CLm | empty} {CLi | [Cdc42 - GDP] [Hras - GDP] [Rac1 - GDP] }
    {CLc | Abl1 Akt1 Atf2 Erks Fak1 Jnks Mekk1 Mlk3 P38s Pak2 Pml Smad2 Smad3 Smad4 Smurf1 Smurf2 Tab1 Tab2 Tab3 Tak1 Traf6 Zfyve16}
    {NUc | Ctdsp1 Ets1 Smad7 Cdc6-gene Cdkn1a-gene Cdkn2b-gene Col1a1-gene Col3a1-gene  Ctgf-gene Fn1-gene Mmp2-gene Pai1-gene Smad6-gene Smad7-gene Tgfb1-gene Timp1-gene Cst6-gene Dst-gene Mmp9-gene Mylk-gene Pthlh-gene Gfi1-gene Csrp2-gene RoRc-gene}) .
\end{lstlisting}
\medskip

\noindent%
En este dish se define un estado inicial (llamado \texttt{Tgfb1Dish}) con varias localizaciones y elementos: 

\begin{itemize}
\item el exterior (localización \texttt{XOut}) que contiene el factor de crecimiento transformante beta1 (\texttt{Tgfb1}); 
\item la localización \texttt{Tgfb1RC} que contiene el receptor beta del factor de crecimiento transformante I y II (\texttt{TgfbR1} y \texttt{TgfbR2}); 
\item la localización \texttt{CLo}, que contiene los elementos adheridos al exterior de la membrana de plasma, está vacía; 
\item la membrana (localización con la etiqueta \texttt{CLm}) también está vacía; 
\item el interior de la membrana (localización con la etiqueta \texttt{CLi}) contiene tres proteínas unidas a GDP: \texttt{Cdc42}, \texttt{Hras} y \texttt{Rac1}; 
\item el citoplasma (localización con la etiqueta \texttt{CLc}) contiene las proteínas \texttt{Abl1}, \texttt{Akt1}, \texttt{Atf2}, \texttt{Erks}, etc.; y 
\item el núcleo (localización con la etiqueta \texttt{NUc}) contiene varios genes (\texttt{Smad7}, \texttt{Tgfb1}, \texttt{Cst6}, etc.) y proteínas (\texttt{Ctdsp1}, \texttt{Ets1}, etc.).
\end{itemize}


\subsection{Modelos en Pathway Logic: reglas de reescritura}

Las reglas de reescritura describen el comportamiento de las proteínas y otros componentes dependiendo de los estados de modificación y los contextos biológicos. Cada regla representa un paso en un proceso biológico como las reacciones metabólicas o las reacciones de señalización intracelular o intercelular~\citep{psb/EkerKLLMS02,DBLP:conf/cmsb/EkerLLST03,DBLP:conf/pacbb/Santos-Buitrago17,DBLP:conf/wsc/Talcott06}. 

El conjunto de reglas de transición se construyen a partir de los hallazgos experimentales publicados en revistas prestigiosas. \citet{nakao1997identification} determinan el comportamiento de las señales del TGF-$\beta$ desde la membrana al núcleo a través de los receptores de serina/treonina cinasa y sus efectores posteriores, denominados proteínas SMAD. 
\medskip

\begin{figure}[h!]
\centering
%\vspace{1mm}
\includegraphics[height=4.0cm]{imagenes/fig_rl931.png}
\caption[Regla de reescritura \texttt{931} en Pathway Logic Assistant]{Representación esquemática de la regla de reescritura \texttt{931.TgfbR1.TgfbR2.by.Tgfb1} en Pathway Logic Assistant.}
\label{fig:rule931}
\end{figure}


Esta regla de reescritura 931 establece: {\em en presencia del receptor I del factor de crecimiento transformante beta \texttt{Tgfb1} en el exterior de la célula (\texttt{XOut}), los receptores \texttt{TgfbR1} y \texttt{TgfbR2} se activan (\texttt{TgfbR1-act} y \texttt{TgfbR2-act}) y se unen entre sí y a \texttt{Tgfb1} (\texttt{[TgfbR1 - act] : [TgfbR2 - act] : Tgfb1}).}
%
En la sintaxis de Maude, este proceso de señalización se expresa mediante la siguiente regla de reescritura: 

\begin{lstlisting}[language=Maude,caption={Regla de reescritura \texttt{931.TgfbR1.TgfbR2.by.Tgfb1}}]
rl[931.TgfbR1.TgfbR2.by.Tgfb1]:
   {XOut | xout Tgfb1 }  
   {Tgfb1RC | tgfb1rc TgfbR1 TgfbR2 }
=> {XOut | xout }        
   {Tgfb1RC | tgfb1rc 
   ([TgfbR1 - act] : [TgfbR2 - act] : Tgfb1) } .  
\end{lstlisting}











